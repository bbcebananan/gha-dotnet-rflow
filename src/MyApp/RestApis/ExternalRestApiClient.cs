using System.Net.Http.Json;
using System.Text.Json;
using Microsoft.Extensions.Options;
using MyApp.Options;

namespace MyApp.Services;

/// <summary>
/// Interface for external REST API client
/// </summary>
public interface IExternalRestApiClient
{
    /// <summary>
    /// Pings the external API to check connectivity
    /// </summary>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>True if the API is reachable</returns>
    Task<bool> PingAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets data from the external API
    /// </summary>
    /// <typeparam name="T">Type of data to retrieve</typeparam>
    /// <param name="endpoint">API endpoint</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The retrieved data</returns>
    Task<T?> GetAsync<T>(string endpoint, CancellationToken cancellationToken = default) where T : class;

    /// <summary>
    /// Posts data to the external API
    /// </summary>
    /// <typeparam name="TRequest">Request type</typeparam>
    /// <typeparam name="TResponse">Response type</typeparam>
    /// <param name="endpoint">API endpoint</param>
    /// <param name="request">Request data</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The response data</returns>
    Task<TResponse?> PostAsync<TRequest, TResponse>(
        string endpoint,
        TRequest request,
        CancellationToken cancellationToken = default)
        where TRequest : class
        where TResponse : class;
}

/// <summary>
/// HTTP client for external REST API integration
/// This would typically be generated by NSwag from an OpenAPI specification
/// </summary>
public sealed class ExternalRestApiClient : IExternalRestApiClient
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<ExternalRestApiClient> _logger;
    private readonly AppConfig _config;

    private static readonly JsonSerializerOptions JsonOptions = new()
    {
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        PropertyNameCaseInsensitive = true
    };

    public ExternalRestApiClient(
        HttpClient httpClient,
        ILogger<ExternalRestApiClient> logger,
        IOptions<AppConfig> config)
    {
        _httpClient = httpClient;
        _logger = logger;
        _config = config.Value;

        // Configure default headers
        if (!string.IsNullOrWhiteSpace(_config.ExternalApiKey))
        {
            _httpClient.DefaultRequestHeaders.Add("X-Api-Key", _config.ExternalApiKey);
        }
        _httpClient.DefaultRequestHeaders.Add("Accept", "application/json");
    }

    /// <inheritdoc />
    public async Task<bool> PingAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(_config.ExternalApiBaseUrl))
            {
                _logger.LogDebug("External API URL not configured, skipping ping");
                return true; // Consider healthy if not configured
            }

            using var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(TimeSpan.FromSeconds(5));

            var response = await _httpClient.GetAsync("health", cts.Token);
            return response.IsSuccessStatusCode;
        }
        catch (TaskCanceledException)
        {
            _logger.LogWarning("External API ping timed out");
            return false;
        }
        catch (HttpRequestException ex)
        {
            _logger.LogWarning(ex, "External API ping failed");
            return false;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error during external API ping");
            return false;
        }
    }

    /// <inheritdoc />
    public async Task<T?> GetAsync<T>(string endpoint, CancellationToken cancellationToken = default)
        where T : class
    {
        try
        {
            _logger.LogDebug("GET request to external API: {Endpoint}", endpoint);

            var response = await _httpClient.GetAsync(endpoint, cancellationToken);
            response.EnsureSuccessStatusCode();

            return await response.Content.ReadFromJsonAsync<T>(JsonOptions, cancellationToken);
        }
        catch (HttpRequestException ex)
        {
            _logger.LogError(ex, "HTTP error during GET to {Endpoint}", endpoint);
            throw new ExternalApiException($"Failed to GET {endpoint}", ex);
        }
        catch (JsonException ex)
        {
            _logger.LogError(ex, "JSON deserialization error for GET {Endpoint}", endpoint);
            throw new ExternalApiException($"Invalid response format from {endpoint}", ex);
        }
    }

    /// <inheritdoc />
    public async Task<TResponse?> PostAsync<TRequest, TResponse>(
        string endpoint,
        TRequest request,
        CancellationToken cancellationToken = default)
        where TRequest : class
        where TResponse : class
    {
        try
        {
            _logger.LogDebug("POST request to external API: {Endpoint}", endpoint);

            var response = await _httpClient.PostAsJsonAsync(endpoint, request, JsonOptions, cancellationToken);
            response.EnsureSuccessStatusCode();

            return await response.Content.ReadFromJsonAsync<TResponse>(JsonOptions, cancellationToken);
        }
        catch (HttpRequestException ex)
        {
            _logger.LogError(ex, "HTTP error during POST to {Endpoint}", endpoint);
            throw new ExternalApiException($"Failed to POST to {endpoint}", ex);
        }
        catch (JsonException ex)
        {
            _logger.LogError(ex, "JSON error for POST {Endpoint}", endpoint);
            throw new ExternalApiException($"Invalid request/response format for {endpoint}", ex);
        }
    }
}

/// <summary>
/// Exception thrown when external API operations fail
/// </summary>
public sealed class ExternalApiException : Exception
{
    public ExternalApiException(string message) : base(message) { }

    public ExternalApiException(string message, Exception innerException)
        : base(message, innerException) { }
}
